🔹 Покрокове пояснення CGD
1 for (index, url) in imageURLs.enumerated()
◦ Беремо кожен URL з масиву imageURLs.
◦ enumerated() повертає кортеж (index, url), щоб ми знали номер картинки і її адресу.
◦ index потім використовується, щоб зрозуміти, у який саме UIImageView вставляти картинку.

2 dispatchGroup.enter()
◦ Говоримо групі: «Я запускаю ще одну задачу, чекай її завершення».
◦ Без enter() група не знатиме, що є нова задача.

3 URLSession.shared.dataTask(with: url)
◦ Створює асинхронний запит на завантаження картинки з інтернету.
◦ Всередині є completion handler ({ data, response, error in ... }), який виконається після завершення завантаження.
◦ Важливо: завдання створюється «на паузі», тому ми викликаємо .resume(), щоб запустити його.

4 if let data, let image = UIImage(data: data)
◦ Перевіряємо, чи прийшли дані (data) і чи можна з них створити картинку (UIImage).
◦ Якщо дані коректні → працюємо з картинкою.
◦ Якщо ні → виводимо помилку.

5 DispatchQueue.main.async { ... }
◦ Оновлення UI можна робити тільки на головному потоці.
◦ Тому ми «повертаємось» у main queue, щоб змінити UIImageView.

6 if index < imageViews.count
◦ Безпека: перевіряємо, чи індекс у межах масиву imageViews.
◦ Інакше можна зловити index out of range, якщо щось піде не так.

7 imageViews[index]?.image = image
◦ Прив’язуємо завантажену картинку до відповідного UIImageView.
◦ Наприклад: index = 0 → картинка піде у imageView1.

8 dispatchGroup.leave()
◦ Коли завдання (успішне чи з помилкою) завершене — повідомляємо групу: «Все, ця задача виконана, можна не чекати її далі».
◦ Це обов’язково, інакше група зависне назавжди, бо буде «думати», що завдання ще виконується.

9 .resume()
◦ Без цього рядка URLSession не почне завантаження.
◦ dataTask створює завдання «заморожене», і .resume() його запускає.

🔹 Таким чином, цикл запускає 3 паралельних запити (бо 3 URL). 🔹 Кожен із них, завершившись, оновлює UI і каже групі, що він «закінчився». 🔹 А коли всі 3 виконаються — у dispatchGroup.notify вже обробляється фінал (зупиняється індикатор і виводиться час).


🔹 Покрокове пояснення:  ASYNC / AWAIT
await withTaskGroup(of: (Int, UIImage?).self) { group in ... }
• Створюємо групу асинхронних задач (TaskGroup).
• of: (Int, UIImage?).self — тип результату кожної задачі: індекс картинки та сама картинка (або nil, якщо помилка).
• await потрібен, бо ми чекаємо, поки група завершить усі задачі.
• TaskGroup дозволяє запускати паралельні асинхронні задачі і збирати їх результати.

for (index, url) in imageURLs.enumerated()
• Беремо кожен URL з масиву imageURLs.
• enumerated() повертає кортеж (index, url), щоб знати номер картинки і її адресу.
• index потім використовується, щоб зрозуміти, у який UIImageView вставляти картинку.

group.addTask { ... }
• Додаємо нову асинхронну задачу в групу.
• Код всередині цього замикання (closure) буде виконуватись паралельно з іншими задачами.
• Результат цієї задачі буде типу (index, UIImage?).

let (data, _) = try await URLSession.shared.data(from: url)
• Асинхронно завантажуємо дані картинки з інтернету.
• await не блокує потік, просто чекає завершення запиту.
• try потрібен, бо запит може кинути помилку.

let image = UIImage(data: data)
• Перетворюємо отримані дані на картинку.
• Якщо дані некоректні → повертаємо nil далі.

return (index, image)
• Повертаємо індекс і картинку як результат задачі.
• TaskGroup збирає результати всіх задач у циклі for await.

catch { print("Async error: \(error)"); return (index, nil) }
• Якщо завантаження не вдалося, ловимо помилку і повертаємо nil.
• Так TaskGroup не зависне через невдалу задачу.

for await (index, image) in group { ... }
• Чекаємо завершення задач групи по мірі готовності.
• Кожного разу, коли якась задача завершилась, ми отримуємо її індекс і картинку.
• for await — сучасний аналог dispatchGroup.notify, але без блокування потоку.

await MainActor.run { ... }
• Повертаємося на головний потік, щоб змінювати UI (обов’язково для UIImageView).
• await чекає, поки код на MainActor завершиться.

if index < imageViews.count { imageViews[index]?.image = image }
• Безпечний доступ до масиву UIImageView.
• Вставляємо завантажену картинку у відповідний UIImageView.

Таким чином:
• Кожна картинка завантажується паралельно.
• UI оновлюється на головному потоці по мірі готовності кожної картинки.
• Помилки обробляються індивідуально, і група не зависає.


Ось порівняльна таблиця GCD vs Async/Await

              Крок                     GCD + DispatchGroup           Async/Await + TaskGroup
1. Підготовка масиву imageView   let imageViews = [imageView1,   Так само: let imageViews =
                                  imageView2, imageView3] –       [imageView1, imageView2,
                                  локальна копія                  imageView3]
                                  масиву
2. Показати індикатор /          activityIndicator.startAnimatingawait MainActor.run {
 заблокувати                     () і                             activityIndicator.startAnimatin
 UI                               view.isUserInteractionEnabled  g();
                                  = false – виконуються на        view.isUserInteractionEnabled
                                  головному                       = false } – обов’язково на
                                  потоці                          головному
                                                                  потоці
3. Старт таймеру                 let startTime = Date()          Так само: let startTime = Date()
4. Створення групи для           let dispatchGroup =             await withTaskGroup(of: (Int,
 паралельних                      DispatchGroup()                 UIImage?).self) { group in ...
 задач                                                            }
5. Ітерація по URL та запуск     for (index, url) in             for (index, url) in
 задач                            imageURLs.enumerated()→         imageURLs.enumerated()→
                                  dispatchGroup.enter() →         group.addTask { ... } → try
                                  URLSession.shared.dataTask(with await
                                 :) { ...                         URLSession.shared.data(from:)
                                  }.resume()
6. Завантаження картинки         Через dataTask + completion     Через try await
                                  handler (data, response,        URLSession.shared.data(from:
                                  error)                          url) – асинхронно, без
                                                                  completion
                                                                  handler
7. Обробка результату / помилки  if let data, let image =        let image = UIImage(data:
                                  UIImage(data: data) → вставка   data); якщо помилка – catch {
                                  картинки в imageView через      print(error) }; результат
                                  DispatchQueue.main.async; якщо  повертається як (index,
                                  помилка –                       image)
                                  print(error)
8. Вставка картинки у UI         Через DispatchQueue.main.async  Через for await (index, image)
                                  { imageViews[index]?.image =    in group { await MainActor.run
                                  image                           { imageViews[index]?.image =
                                  }                               image }
                                                                  }
9. Завершення задачі у групі     dispatchGroup.leave() –         Повертається (index, image) або
                                  обов’язково, навіть при         (index, nil) – TaskGroup
                                  помилці                         автоматично відслідковує
                                                                  завершення
10. Дочікування завершення всіх  dispatchGroup.notify(queue:     for await ... in group + код
 задач                            .main) { ... }– зупинка         після withTaskGroup + await
                                  індикатора, розблокування UI,   MainActor.run { ... }– зупинка
                                  обчислення                      індикатора, розблокування UI,
                                  часу                            обчислення
                                                                  часу
11. Потоковість                  Completion handler виконується  TaskGroup виконує задачі
                                  у фоні, UI оновлюється через    паралельно, UI оновлюється
                                  DispatchQueue.main.async        через
                                                                  MainActor
12. Обробка помилок              В completion handler через if   Через do/catch всередині
                                  let                             group.addTask
                                  error
13. Читабельність коду           Більше вкладених замикань,      Лінійний код, чітко видно
                                  блоки enter/leave – важче       послідовність дій, без
                                  читати                          enter/leave

💡 Висновки:
• GCD + DispatchGroup: класичний спосіб, працює стабільно, але багато boilerplate коду і блоки enter/leave легко забути → deadlock.
• Async/Await + TaskGroup: сучасний Swift-підхід, простіший і чистіший, без зайвих вкладень, автоматично відслідковує завершення задач, UI через MainActor без DispatchQueue.main.async.
• За логікою – обидва підходи роблять те саме: паралельне завантаження картинок і оновлення UI після завершення всіх задач.

