— Functions: параметри, labels, default/variadic, inout, throws.

1️⃣ У Swift функції мають параметр labels (argument labels) і імена параметрів (parameter names).
	– Яка між ними різниця? І як викликати функцію без зовнішнього label?

2️⃣ Як у Swift задати значення за замовчуванням для параметра? Що відбувається при виклику?
3️⃣ Що таке variadic parameters? Наведи приклад простої функції з таким параметром.
4️⃣ Що таке inout-параметри? Наведи приклад, коли вони потрібні.

5️⃣ Як у Swift реалізовано error handling у функціях?
	– Що означає throws у сигнатурі?
	– Як обробляти помилки при виклику такої функції?

Відповіді:

1. Так argument labels - це у нас мітки параметрів і вони використовуються при вилкику функції. Parameter names - це імена параметрів і вони використовуються для звернення до параметру у тілі функції.  Щоб викликати функцію без зовнішнього label нам потрібно використати _. Тобто замість використання зовнішнього параметру - ми використовуємо - нижній прочерк (_). Це дає змогу викликати функцію не використовуючи мітку аргументу.

2. Ну тут дуже просто, при оголошенні функції - вказуємо параметер з відповідним типом даних і одразу ж задаєм значення. Тобто:  func driveCar(brand: String = "Ferrarri", maxSpeed: Int = 350, color: String) { }. Color - у нас тут просто як параметер, без значення за замовчуванням). 
При виклику функції ми маємо лише вказати значення для параметра Color. Значення "Ferrarri" та 350, виведуться за замовчуванням.

3. Варіаційні параметри - це такі параметриб що приймають нуль або більше значень зазначеного типу. 
Приклад: func printNumbers(numbers: Int...) {
	for number in numbers {
		print(number)
	}
}

printNumbers(numbers: 1, 2, 3, 4, 5) // ВИВІД:  1, 2, 3, 4, 5

4. Inout параметри це параметри що дозволяють змінювати значення (вхідну змінну) у вилику. 

5. У swift -  error handling реалізовано таким чином щоб просто повертати результат, ми будемо мати можливість сповіщати про помилки які виникли при певній сесії функції. Якщо помилка стається, функція не поверне значення,  а кинеться помилка. 
throws у сигнатурі - означає  кинь помилку. Щоб фкнкція змогла кидати помилки. Це ключове слово вказується після параметрів та потім вказується тип повернення. 
Обробляти помилки при виклику такої функції можна через блок do - catch.  У блоці do - намагаєтесь виконати код, який може кинути помилку використовуючи try(спробуй) повернути значення -  інакше виконується блок коду з catch - що ловить помилку і обробляє її.
Наприклад:

func doSomething() throws -> String {
	if true {
		throw SimpleError.somethingWentWrong
	}
		return "Success"
}

Обробка:
do {
	let result = try doSomething()
	print(result)
} catch {
	print("Error: \(error)")
	// або ж SimpleError.somethingWentWrong
}

Chat Answers:

1️⃣ Argument labels vs parameter names
✅ Все правильно.
Тільки уточню: у сигнатурі func greet(person name: String) {}

person — argument label (зовнішнє ім’я, використовується при виклику: greet(person: "Max"))

name — parameter name (всередині функції).
Якщо хочеш без label → _ name: String у сигнатурі.

2️⃣ Default parameters
✅ Приклад ок.
Нюанс: параметри зі значенням за замовчуванням у Swift завжди йдуть після обов’язкових параметрів.
При виклику можна вказати значення лише для тих, що без дефолту. Swift підставить решту автоматично.

3️⃣ Variadic parameters
✅ Визначення й приклад правильні.
Нюанс: у функції може бути лише один variadic-параметр, і він має йти останнім у списку параметрів.

4️⃣ inout parameters
✅ Вірно.
У Swift треба передавати таку змінну з амперсандом:

func swapNumbers(_ a: inout Int, _ b: inout Int) {
    let temp = a
    a = b
    b = temp
}

var x = 10
var y = 20
swapNumbers(&x, &y) // тепер x=20, y=10


5️⃣ throws
✅ Правильно пояснив.
Тільки маленьке уточнення: throws означає, що функція може кинути будь-яку помилку, яка відповідає Error.
При виклику:

try — звичайна спроба

try? — перетворює результат у Optional (помилка = nil)

try! — форсований виклик (якщо помилка — креш).

do {
    let data = try loadData()
} catch {
    print(error)
}